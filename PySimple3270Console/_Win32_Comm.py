# region License
"""
 * SimplRPA - A simple RPA library for Python and C#
 *
 * Copyright (c) 2009-2021 Michael S. Halpin
 * Modifications (c) as per Git change history
 *
 * This Source Code Form is subject to the terms of the Mozilla
 * Public License, v. 2.0. If a copy of the MPL was not distributed
 * with this file, You can obtain one at
 * https://mozilla.org/MPL/2.0/.
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial
 * portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT
 * LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
"""
# endregion
# region IMPORTS
import sys
import pywintypes
import json
import time
import win32file
import win32pipe
import _Steganography
import _Comm_Convergence as cc
# endregion


# region USE NAMED PIPES FOR WINDOWS CROSS PLATFORM COMMUNICATION
import Screen
import _Platform_Convergence


class Pipe:
    @staticmethod
    def set(channel, text):
        """
        Sends a message cross development platform to another application running on Windows.
        :param channel: The channel to write to.
        :param text: The text message to send.
        :return: void
        """
        count = 0
        outpipe = win32pipe.CreateNamedPipe(
            r'\\.\pipe\Simple' + channel,
            win32pipe.PIPE_ACCESS_DUPLEX,
            win32pipe.PIPE_TYPE_MESSAGE | win32pipe.PIPE_READMODE_MESSAGE | win32pipe.PIPE_WAIT,
            1, 65536, 65536,
            0,
            None)
        try:
            if not isinstance(text, str):
                text = json.dumps(text)
            win32pipe.ConnectNamedPipe(outpipe, None)  # Connect to pipe.

            some_data = str.encode(text)  # Prep for sending. Using ASCII (this is efficient)
            win32file.WriteFile(outpipe, some_data)  # Send message.

        finally:
            win32file.CloseHandle(outpipe)  # Dispose of pipe.

    @staticmethod
    def get(channel, length=1024):
        """
        Listens for an incoming message from another application running on Windows
        :param channel: The channel to listen in on.
        :param length: The number of characters to read per transaction. (1024 is default)
        :return: string
        """
        quit = False

        while not quit:
            try:
                handle = win32file.CreateFile(
                    r'\\.\pipe\Simple' + channel,
                    win32file.GENERIC_READ,
                    0,
                    None,
                    win32file.OPEN_EXISTING,
                    0,
                    None
                )
                response = win32file.ReadFile(handle, length)
                rl = len(response[1])
                rsp = response[1].decode('utf-8')[0:1000]

                if rl == 1002:
                    while rl == 1002:
                        response = win32file.ReadFile(handle, length)
                        rl = len(response[1])
                        if rl == 1002:
                            rsp += response[1].decode('utf-8')[0:1000]
                        else:
                            if not str.startswith("#END_OF_FILE"):
                                rsp += response[1].decode('utf-8')
                            else:
                                break
                    ba = bytes(rsp, 'utf-8')

                    quit = True
                    win32file.CloseHandle(handle)
                    return ba
                # endregon

                quit = True
                win32file.CloseHandle(handle)
                return bytes(response[1])
            except pywintypes.error as e:
                if e.args[0] == 2:
                    time.sleep(1)
                elif e.args[0] == 109:
                    raise Exception("Protocol broken.")

    @staticmethod
    def run(key, iv, input, output, verbose_level=0):
        """
        This method runs as a service managing communications between applications and executing requested actions.
        All communications are encrypted by default using a key and iv generated on the client application using
        input/output channels which are also generated by the client.
        :param key: The encryption key to use.
        :param iv: The initialization vector to use.
        :param input: The input channel to listen on.
        :param output: The output channel to write to.
        :param verbose_level: The level of information to print to console. (0=None,1=Basic Info,2=Advanced Info)
        :return: void
        """
        if verbose_level > 0:
            cc.log_header("Using Win32 Pipe Protocol")

        while True:
            try:
                # region Listen for next request from the client.
                resp = Pipe.get('Rpa_' + input).decode('utf-8').rstrip()
                rsp = json.loads(resp)
                pkg = rsp['package']
                jsn = _Steganography.decrypt(pkg, key, iv)
                wr = json.loads(jsn)
                # endregion

                reply = cc.run_method(verbose_level, wr, jsn, key, iv)

                if '"length":' in reply:
                    Pipe.set('Rpa_' + output, reply)
                else:
                    # region Send response back to client.
                    rep = _Steganography.package(reply, key, iv)
                    Pipe.set('Rpa_' + output, rep)
                    # endregion
            except:
                e_type, e_value, e_trace = sys.exc_info()
                return {"response": "EXCEPTION", "content": str(e_type) + ": " + str(e_value)}

    @staticmethod
    def query(jsn, c2s, s2c, key, iv):
        """
        Queries the server.
        :param jsn: The kind of query to perform..
        :param c2s: The client to server channel.
        :param s2c: The server to client channel.
        :param key: The encryption key.
        :param iv: The encryption initialization vector.
        :param tween: How you would like to tween the mouse.
        :param log_screenshot: If true the method takes a screenshot after the action.
        :param use_widget: If true displays the field highlighting widget during operation.
        :return: void
        """
        Pipe.set(c2s, jsn)
        packet = json.loads(Pipe.get(s2c))
        if packet['response'] == 'EXCEPTION':
            raise Exception(packet['content'].ToString())
        encrypted = packet["content"]
        content = _Steganography.decrypt(encrypted, key, iv)
        rsp = json.loads(content)
        return rsp
    # endregion
